[*Up*](README.md)

# Vnodes

- Holes: `null`, `undefined`, and booleans
- Text: anything other than `null`, `undefined`, a boolean, or an object
    - Note: this uses `String(value)` to coerce, so symbols *are* converted to a string first.
- Fragments: `[...children]`
- Retain: `m.RETAIN`
- Attribute objects: `{...attrs}`
- Elements: `m("tag", ...children)`
- Components: `m(Comp, ...children)`
- Link points: `m.link(id, ...children)`
    - `id` - The identity to link the fragment to.
    - `m.if(cond, {then, else})` is sugar for `m.link(!!cond, cond ? attrs.then() : attrs.else())`.
- State points: `m.state(init, ...children)`
    - `vnode = init(attrs, info, env)` is called with the current info object.
    - `m(Comp, ...children)` is just sugar for `m.link(Comp, m.state(Comp, ...children))`
- Trusted raw fragments: `m.trust(text)`
- Keyed lists: `m.each(list, key, view)`
    - `key: (x, i) => key` - Get the property key
    - `view: (x, i) => vnode` - Get the corresponding vnode
    - `list` is an iterable.
    - Keys are coerced to property keys on storage.
    - Keys are read in full before each body vnode.
    - Keys are diffed by value + number of instances that preceded it - duplicate keys are permitted.
        - Yes, this does mildly complicate the model, but only mildly, and for the common case, it shouldn't matter. Also, it means you can't possibly run into undefined behavior.
    - You can iterate maps via `m.each(map, 0, ([k, v]) => ...)`
- On catch: `m.catch(callback, ...children)`
    - `await callback(e, stack, isFatal)` - Called with each error that propagates from children after this in the subtree as well as a component `stack` trace, may rethrow or return rejected promise to propagate
    - `isFatal` is whether the error was fatal (originated from any point other than `beforeRemove`) or not.
    - Errors caught include both errors in streams and errors and rejections caught from event handlers. It does *not* include errors thrown from the function itself.
    - Caught errors are batched and scheduled to be reported on the next tick.
    - This exists mainly for error reporting, but can be used in other ways like with async network requests.
    - When an error propagates past a subtree, that subtree is synchronously removed with inner `done` callbacks invoked. If any of those throw, their errors are also added to the `errors` list.
    - Resolution searches back to the first child, then up to the parent, then back to its first child, and so on, until it finds such a hook.
- Static: `m.create(StaticType, vnode)`
    - `vnode` - The static subtree, assumed to never change outside attributes
    - This does *not* have a separate factory, as it's expected to only be generated by tooling.
    - This is explained later.

### JSX

JSX is derived from the `m` sugar above, and in addition to the above, you can use the following:

- Fragments: `<>...</>`, `<m.Fragment>...</m.Fragment>`
    - Make sure to set `"pragmaFrag": "m.Fragment"` in your `.babelrc.js`
- Attribute objects: `<m.Attrs key="value" {...} />`
- Elements: `<tag key="value" {...}>...</tag>` → `m.create("tag", <><m.Attrs key="value" {...} />...</>)`
- Components: `<Comp key="value" {...}>...</Comp>` → `m.link(Comp, <><m.Attrs key="value" {...} />...</>)`

In the future, a custom JSX plugin may add additional semantics to this:

- `{...attrs}` would then work as separate entries
- Duplicate class names would be permitted

A custom JSX plugin would exist for optimization, but use is as simple as setting the JSX pragma to `m` and the JSX fragment pragma to `m.Fragment`.

This will require a custom JSX plugin, but mainly for the attributes handling part (It needs to be static for sensible semantics) and for setting the `is` value correctly. Note that the `is` value must always be static to be used correctly.

### Tags

Tags can be any HTML tag or any component reference, and classes may be added to it via `.class-name`. `is` names for customized builtin elements may be specified via `name@is-name`. The full tag name, including class names is considered part of the element's identity (think: `div.container` vs `div.alert` in Bootstrap, a saved selector variable for [Tachyons](https://tachyons.io/) acting as a pseudo-primitive), so it's *highly* recommended to keep it static. Unlike past Mithril, arbitrary selectors are no longer supported - it's just a simple tag name with optional class names.

> This is handled within the renderer, not the hyperscript level, for four reasons:
>
> 1. It's quite often that certain class names are really meaningfully part of the "tag". For instance, if you're using Bootstrap, `<div class="container">...</div>` and `<div class="row">...</div>` are two *very* different things, and would more meaningfully just be custom elements.
> 1. It differs from class name handling internally by a single character (space vs dot) + a trivial sanity check for syntax (to ensure no spaces exist), and it's easy to parse.
> 1. It's very easy to test and validate, and this entire thing can be tested using a single easily-optimized regexp.
> 1. Not all renderers have any need to make sense of it - a hypothetical terminal renderer would have no need to deal with it.

There's three reasons I mandate the tag name be present:

- It's one of the biggest stumbling blocks people have had with selectors. I see this as a frequent stumbling block that people write `m(".foo")` instead of `m("span.foo")` and wonder why things aren't working. The implicit default clearly is tripping people up, and the common case is only really saving 3 characters for something that you're more often changing than writing to begin with. (Hyperscript isn't exactly Emmet.)
- It avoids the question of what to do with `m("")` - if you follow the rules logically, it's equivalent to `m("div")`, but intuitively, for many, it's equivalent to `null`.
    - Relevant GitHub issue: [#723](https://github.com/MithrilJS/mithril.js/issues/723)
    - Relevant Gitter discussion: [11 Dec 2015](https://gitter.im/mithriljs/mithril.js/archives/2015/12/11), [12 Dec 2015](https://gitter.im/mithriljs/mithril.js/archives/2015/12/12)
- It's less implicit information you have to keep in mind and infer. If it says `div`, you know at a glance it's a `<div>` that it renders to. 99% of development isn't writing, but reading, and that "at a glance" information is incredibly valuable to have. I find myself, as a Mithril maintainer, taking twice as long to process `m(".widget")` than `m("button.confirm")` or even `m("div.widget")`. Even though it's still pretty quick for me, I have to stop and mentally reparse after reading the tokens (the implied `div` in `div.widget` rather than just being decorated `widget`) as my brain reads the word before realizing that's the class name and not the tag name.

## Low-level

Each of these are normalized to a low-level representation, where non-holes have two properties: `%` and `_`. The first, `%`, is used to both differentiate vnodes from other objects and to tell what kind of vnode it is. These are created via a simple factory:

```js
m.create = function (type, data) {
    return {"%": type, _: data}
}
```

And here's how each type is represented:

- Hole: `null`, `undefined`, `true`, `false`
- Text: strings, numbers
- Fragment: arrays of vnode children
- Attribute: any non-array object without a numeric `"%"` property
- Retain: `m.create(0, void 0)`
- Element: `m.create(1, [tag, ...children])`
    - `tag: string` is the element tag name.
    - Customized builtins' `is` values are specified by passing them as an array, like `["p", "custom-name"]`.
    - `children: Child[]` is an array of vnode children.
- State: `m.create(2, body)`
    - `body: (info: Info, env: Environment) => Child` is the state body.
- Link: `m.create(3, [id, ...children])`
    - `id: any` represents the current state. This can be any value, and is compared via `SameValueZero`.
    - `children: Child[]` is an array of vnode children.
- Keyed: `m.create(4, [key, body, ...])`
    - `key: any` contains the property keys for each body. In IE, keys are treated as property keys for performance reasons, but in modern browsers, `Map`s are used, so any reference type can be used in them.
    - `body: Child` is an array of vnode children where each child corresponds to the key of the same index in `keys`. These are immediately invoked for both easier error handling and better performance when processing.
    - For performance, these are interleaved.
- Static hint: `m.create(5, vnode)`
    - `vnode: Vnode` is the vnode to decorate.
    - On create, this is simply recursed through, but on update, the following things happen:
        - Children are assumed to never change primitive type
        - Element tags, link keys, and keyed fragment keys are never diffed.
    - This exists as an optimization for tooling to leverage, but it's optional. Tooling should also consider conditionally using `info.isInitial() ? m.RETAIN : vnode` for deeply static trees instead of this, too.
- Catch error in subtree: `m.create(6, [callback, ...children])`
    - `callback: () => Promise<void>` is the callback to run on error.
    - `children: Child[]` is an array of vnode children.
- Component: `m.create(7, [Comp, ...children])`
    - `Comp: Component` is the component tag.
    - `children: Child[]` is an array of vnode children.

Note that these vnodes are immutable. You can feel free to reuse them, and unlike in most other frameworks, these are *very* lightweight. For contrast:

- React, which uses a persistent DOM, features 6 fields in production mode.
- Inferno, which does mostly the same thing we do in v2, features nine.

Super lightweight DOM nodes will help keep memory usage and churn down a lot, and engines are really good at optimizing for small objects that comprise 99% of object use anyways. And in the case of Mithril views, this could mean you're generating a fraction of the GC churn each render.

We can always build our own specialized nodes as necessary, and we can have much greater flexibility with our internal representation.

#### Why only two properties?

Well, this is a space trade-off, actually. When engines allocate objects, they usually only allocate the real number of properties that exist, but when they allocate non-empty arrays, they always allocate at least 8 entries. In addition, GC generations are typically sized in terms of their reserved byte sizes, not their number of handles, so if we can reduce our footprint here, more things can fit in the nursery and next level down, and so we're leveraging the GC more effectively.

For us, most our special vnodes only need 2 pieces of data, a type and a value or array. And for those that need more, they all include children. Most vnodes have more than zero children (including attributes), so we have to allocate the array regardless, but most also have 7 or fewer children, so that's at least one slot that's wasted if we don't use it. As for speed impact, it's minimal but you'll see fewer GC spikes.

As for internal usage, we can better control our GC behavior if we use our own model. We also don't need any special API contracts to do so.

## Attributes

Attribute vnodes represent attributes, and you can use them literally. They're merged as they're found, and are resolved and applied while inititalizing the relevant parent.

Note that attribute vnodes cannot be returned from keyed fragments except nested in elements or components, and an error will be thrown from that vnode if such an attempt is made. (In general, it doesn't make sense anyways.) However, lifecycle vnodes can still be used in them.

`class:` and `style:` attributes would support an object of booleans, merged with previous class names/style properties instead of simply overwritten. (A class is rendered if it's present and all conditions on it are truthy.) Class strings are sugar for just `class: {[classString]: true}` and style strings are parsed into style objects.

The `on:` attribute specify event handlers. Keys are event names, and values are either functions or `[key, func]` pairs. For DOM events, you can specify `capture: true` by using `event@capture` instead. They're called as `on.event(value, capture)`, where `value` is the received event value (a DOM event for DOM vnodes) and `capture` is a capture object. If a promise is returned and it rejects, this catches that and reports it as the usual component error.

The `[key, func]` variant is spiritually similar to `m.withAttr`, but takes advantage of its primitive nature to be context-dependent:

- For DOM vnodes, it returns the relevant property/attribute value for the current element target, and the choice of element vs attribute is detected similarly to how that key is applied as a property normally.
- For components, it's just sugar for `value => func(value[key])`, using the current ref at the time of reading.

> Why reinstate it after it was removed? Well, unlike `m.prop()` which was an utter waste of memory for what could just as easily be done in a closure, the existence of the [component DSL and its `slot`](component-dsl.md#state) makes it *much* more useful. Also, it being a simple array pair means it's actually smaller to use than `event.target.key` directly if that's all you're using.

`capture` objects have a few methods:

- `capture.event()` - Invoke `ev.preventDefault()` + `ev.stopPropagation()` if it's a DOM event, have the corresponding `attrs.on.event(...)` call return `false` if it's a user event.
    - This does not prevent subsequent events from running, but they can check for previous capture via `capture.eventCaptured()`
- `capture.eventCaptured()` - Returns `true` if the event was captured, `false` otherwise.
- `capture.redraw()` - Skip the redraw.
- If a listener throws an error or returns a promise that rejects, the error propagates from the component that created the listener, *not* from the component the event was fired from. (Makes for easier, more intuitive error handling.)

## Refs

The `vnode.dom` from v1/v2 is replaced with refs here, which capture via the vnode `m.capture(ref)`. Refs are simple `{current}` objects you can create via `m.ref(init)` that let you pull out a given vnode into a given scope, and they're useful for DOM manipulation. `m.capture(ref)` captures the ref of the parent it's used as a child of, and inside components at the top level, it works as if it were just substituted there at that parent position.

It may sound like it's bound to get unwieldy, but it actually simplifies and streamlines some things. It's pretty easy to get right, and pretty simple to understand, especially since functions aren't involved aside from the various controller lifecycle hooks.
